# -*- coding: utf-8 -*-
"""HW2 FINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oKqiWz3p5kErAifWy-PtFaBEffVpkY0b
"""

!apt-get install -y -qq software-properties-common python-software-properties module-init-tools
!add-apt-repository -y ppa:alessandro-strada/ppa 2>&1 > /dev/null
!apt-get update -qq 2>&1 > /dev/null
!apt-get -y install -qq google-drive-ocamlfuse fuse
from google.colab import auth
auth.authenticate_user()
from oauth2client.client import GoogleCredentials
creds = GoogleCredentials.get_application_default()
import getpass
!google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} < /dev/null 2>&1 | grep URL
vcode = getpass.getpass()
!echo {vcode} | google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret}

!mkdir -p drive
!google-drive-ocamlfuse drive

import os
os.chdir("drive")

!pwd

#for each play, we read the input file
f = open("input.txt","r")
fl = f.readlines()
gametype = fl[0]
player_type = fl[1]
if(player_type=="BLACK"):
  color = 'b'
if(player_type=="WHITE"):
  color = 'w'
time_allocated = fl[2]
game = []
#we are reading the game board the whole line at a time
for i in range(1,17): #really iteration from 0-16
  game.append((fl[2+i]).split())


#blah
game_board=[]
board = dict()
for i in range(0,16): #this is y
#   print(list(game_board[x][0]))
  game_board.append(list(game[i][0]))
  for j in range(0,16): #this is x
    board.update({(j,i):game[i][0][j]})


# states = generate_states(....)
# for s in states:
#   states[s]+=curr_utility
# minimax()

def eval_black(game_board): #we input a list of the gameboard and get the utility, usually from the enemy
    bpawn_coord = dict()
    bpawn_utility = dict()
    color='B'
    count = 0 #this is to enumerate all the pawns
    for i in range(0,16): #iterating rows, y MAYBE CAN CHOOSE A SMALLER SUBSET
      for j in range(0,16): #iterating columns, x
        if(game_board[i,j]==color):
          #note down the coordinates along with its utility
  #         bpawn_coord.update({'id':count,'coord':[j,i]})
          bpawn_coord.update({count:(j,i)})
          #to get the utility of the pawn, identify the diagonal, and multiply.
          diag = i+j #this gives us the NW to SE diagonal
          if((diag>=0)&(diag<6)):
            ut= diag-50
          if((diag>25)&(diag<=31)):
            ut=100
          if((diag>=6)&(diag<=25)):
            ut= diag-5
          bpawn_utility.update({(j,i):ut}) #used to be count:ut, may not need bpawn_coord after this
 
    return sum(bpawn_utility.values())

def eval_white(game_board): #we input a list of the gameboard and get the utility, we need to do this only once at beg
    wpawn_coord = dict() #maybe dont need this
    wpawn_utility = dict()
    color='W'
    count = 0 #this is to enumerate all the pawns
    for i in range(0,16): #iterating rows, y MAYBE CAN CHOOSE A SMALLER SUBSET
      for j in range(0,16): #iterating columns, x
        if(game_board[i,j]==color):
          #note down the coordinates along with its utility
  #         wpawn_coord.update({'id':count,'coord':[j,i]})
          wpawn_coord.update({count:(j,i)})
          #to get the utility of the pawn, identify the diagonal, and multiply.
          diag = i+j #this gives us the NW to SE diagonal
          if((diag>=0)&(diag<6)):
            ut=-50-diag
          if((diag>25)&(diag<=31)):
            ut=-50
          if((diag>=6)&(diag<=25)):
            ut = 25-diag
          wpawn_utility.update({(j,i):ut}) #used to be count:ut, may not need bpawn_coord after this
  #         pawn_utility.update({'id':count,'utility':util})
   
    return sum(wpawn_utility.values())

def eval_state(game_board,player): #gives us utility of state depending on who the player is
  wu = eval_white(game_board)
  bu = eval_black(game_board)
  if(player=='W'):
    return wu-bu
  if(player=='B'):
    return bu-wu
  
print(eval_state(board,'B'))

class Black:
  
#   def __init__(self,game_board,color):
#     self.color = color
#     self.game_board = game_board

  def evaltar(self,x,y):
    diag = x+y #this gives us the NW to SE diagonal
    if((diag>=0)&(diag<6)):
      ut=0
    if((diag>25)&(diag<=31)):
      ut=50
    if((diag>=6)&(diag<=25)):
      ut= diag-5
    return ut
    
  def eval_state(self,game_board,color): #we input a list of the gameboard and get the utility, usually from the enemy
    bpawn_coord = dict()
    bpawn_utility = dict()
    count = 0 #this is to enumerate all the pawns
    for i in range(0,16): #iterating rows, y MAYBE CAN CHOOSE A SMALLER SUBSET
      for j in range(0,16): #iterating columns, x
        if(game_board[i][j]==color):
          #note down the coordinates along with its utility
  #         bpawn_coord.update({'id':count,'coord':[j,i]})
          bpawn_coord.update({count:(j,i)})
          #to get the utility of the pawn, identify the diagonal, and multiply.
          diag = i+j #this gives us the NW to SE diagonal
          if diag in range(0,5):
            ut=0
          if diag in range(25,31):
            ut=50
          else: ut= d-5
          bpawn_utility.update({(j,i):ut}) #used to be count:ut, may not need bpawn_coord after this
  #         pawn_utility.update({'id':count,'utility':util})

  def jump(self,xcurr,ycurr,game_board,ind): #we want to return a list of states that we can go to
    count=0
    parent=dict()
    neighbors=dict()
    final_states=dict()
    x=xcurr
    y=ycurr
    nodes=0
    parent=dict()
    if(ind>0): #try a series of one jumps
#       print(ind)
      try: #need to make sure it does not go out of bounds
        if((game_board[x+1,y-1]!='.')&(game_board[x+2,y-2]=='.')):
          parent.update({(x+2,y-2):(xcurr,ycurr)})
          neighbors.update({(x+2,y-2):self.evaltar(x+2,y-2)})
      except KeyError:
        pass
      try:
        if((game_board[x+1,y]!='.')&(game_board[x+2,y]=='.')):
          parent.update({(x+2,y):(xcurr,ycurr)})
          neighbors.update({(x+2,y):self.evaltar(x+2,y)})
      except KeyError:
        pass
      try:
        if((game_board[x+1,y+1]!='.')&(game_board[x+2,y+2]=='.')):
          parent.update({(x+2,y+2):(xcurr,ycurr)})
          neighbors.update({(x+2,y+2):self.evaltar(x+2,y+2)})
      except KeyError:
        pass
      try:
        if((game_board[x,y+1]!='.')&(game_board[x,y+2]=='.')):
          parent.update({(x,y+2):(xcurr,ycurr)})
          neighbors.update({(x,y+2):self.evaltar(x,y+2)})
      except KeyError:
        pass
      try:
        if((game_board[x-1,y+1]!='.')&(game_board[x-2,y+2]=='.')):
          parent.update({(x-2,y+2):(xcurr,ycurr)})
          neighbors.update({(x-2,y+2):self.evaltar(x-2,y+2)})
      except KeyError:
        pass
      
    return neighbors,parent 
      
  def all_jump(self,xcurr,ycurr,game_board,ind):
    if(ind==1):
      neigh,par = self.jump(xcurr,ycurr,game_board,1)
      w,u = self.move_adjacent(xcurr,ycurr,game_board)
      par.update(u)
      target_queue = sorted(neigh,key=neigh.__getitem__, reverse=True)
      target_queue.extend(w)
      return target_queue,par
    if(ind==2):
      res=dict()
      p=dict()
      neigh,par = self.jump(xcurr,ycurr,game_board,1)
      w,u = self.move_adjacent(xcurr,ycurr,game_board)
      par.update(u)
      res.update(neigh)
#       p.update(par)
      for n in neigh:
        child,parent = self.jump(n[0],n[1],game_board,1)
#         res.update(child)
#         p.update(parent)
        res.update(child)
        par.update(parent)
      target_queue = sorted(neigh,key=neigh.__getitem__, reverse=True)
      target_queue.extend(w)
      if not target_queue:
        n,p = self.all_jump(xcurr,ycurr,game_board,1)
        return n,p
      else:
        return target_queue,p
    if(ind==3):
      res=dict()
      p=dict()
      neigh,par = self.jump(xcurr,ycurr,game_board,1)
      w,u = self.move_adjacent(xcurr,ycurr,game_board)
      par.update(u)
      res.update(neigh)
      for n in neigh:
        child,parent = self.jump(n[0],n[1],game_board,2)
        res.update(child)
        p.update(parent)
        for c in child:
          ch, pa = self.jump(n[0],n[1],game_board,1)
          res.update(ch)
          p.update(pa)
      target_queue = sorted(res,key=res.__getitem__, reverse=True)
      target_queue.extend(w)
      if not target_queue:
        n,p = self.all_jump(xcurr,ycurr,game_board,2)
        return n,p
      else:
        return target_queue,p

  def move_adjacent(self,x_curr,y_curr,game_board): #need to alter this so we traverse to only the most strategic moves
    x = x_curr
    y = y_curr
    neighbors = dict()
    parent=dict()
    if(y>=1):
      try: #need to make sure it does not go out of bounds
        if(game_board[x+1,y-1]=='.'):
          ut = self.evaltar(x+1,y-1)
          neighbors.update({(x+1,y-1):ut})
      except KeyError:
        pass
    try:
      if(game_board[x+1,y]=='.'):
        ut = self.evaltar(x+1,y)
        neighbors.update({(x+1,y):ut})
    except KeyError:
      pass
    try:
      if(game_board[x+1,y+1]=='.'):
        ut = self.evaltar(x+1,y+1)
        neighbors.update({(x+1,y+1):ut})
    except KeyError:
      pass
    if(x>=1):
      try:
        if(game_board[x-1,y+1]=='.'):
          ut = self.evaltar(x-1,y+1)
          neighbors.update({(x-1,y+1):ut})
      except KeyError:
        pass
    try:
      if(game_board[x,y+1]=='.'):
        ut = self.evaltar(x,y+1)
        neighbors.update({(x,y+1):ut})
    except KeyError:
      pass
      
    for n in neighbors:
      parent.update({(n[0],n[1]):(x,y)})
    targets = sorted(neighbors,key=neighbors.__getitem__, reverse=True)
    return targets, parent

# def check_time(time): #checks the time and gives us the index and depthcutoff
black = Black()
c,p = black.all_jump(1,3,board,3)
print(c)
print(p)

a = {(1,2),(2,2),(3,5)}
a.add((6,7))
for x in a:
  print(x[0])

# white = White()
# j = white.move_adjacent(6,0,board)
# print(j)
# black = Black()
# h = black.jump(5,1,board,2)
# print(h)

# class test:
#   gameboard=[[]]
#   def __init__(self,gameboard):
#     self.gameboard=gameboard
    
# t = test(game_board)
# print(t.gameboard)

# import time
# start=time.time()
# mini = minimax(board,'B',1,1,1) #board, player, dcutoff, ind, time_give
# # print(eval_state(mini,'B'))
# finish=time.time()
# print("time:",finish-start)
# show_state(mini)

class White: 
#   game_board=dict()
#   color=''
  
#   def __init__(self,game_board,color):
#     self.color = color
#     self.game_board = game_board

  def evaltar(self,x,y):
    diag = x+y #this gives us the NW to SE diagonal
    if((diag>=0)&(diag<6)):
      ut=50
    if((diag>25)&(diag<=31)):
      ut=0
    if((diag>=6)&(diag<=25)):
      ut= 25-diag
    return ut       
    
  def eval_white(self,game_board,color): #we input a list of the gameboard and get the utility, we need to do this only once at beg
    wpawn_coord = dict() #maybe dont need this
    wpawn_utility = dict()
    count = 0 #this is to enumerate all the pawns
    for i in range(0,16): #iterating rows, y MAYBE CAN CHOOSE A SMALLER SUBSET
      for j in range(0,16): #iterating columns, x
        if(game_board[i,j]==color):
          #note down the coordinates along with its utility
  #         wpawn_coord.update({'id':count,'coord':[j,i]})
          wpawn_coord.update({count:(j,i)})
          #to get the utility of the pawn, identify the diagonal, and multiply.
          diag = i+j #this gives us the NW to SE diagonal
          if diag in range(0,5):
            ut=50
          if diag in range(25,31):
            ut=0
          else: ut= 25-d          
          wpawn_utility.update({(j,i):ut}) #used to be count:ut, may not need bpawn_coord after this
  #         pawn_utility.update({'id':count,'utility':util})
    return wpawn_utility

  def jump(self,xcurr,ycurr,game_board,ind): #we want to return a list of states that we can go to
    count=0
    parent=dict()
    neighbors=dict()
    x=xcurr
    y=ycurr
    nodes=0
    if(ind>0):
      try: #need to make sure it does not go out of bounds
          if((game_board[x+1,y-1]!='.')&(game_board[x+2,y-2]=='.')):
            parent.update({(x+2,y-2):(xcurr,ycurr)})
            neighbors.update({(x+2,y-2):self.evaltar(x+2,y-2)})
      except KeyError:
        pass
      try:
          if((game_board[x,y-1]!='.')&(game_board[x,y-2]=='.')):
            parent.update({(x,y-2):(xcurr,ycurr)})
            neighbors.update({(x,y-2):self.evaltar(x,y-2)})
      except KeyError:
        pass
      try:
          if((game_board[x-1,y-1]!='.')&(game_board[x-2,y-2]=='.')):
            parent.update({(x-2,y-2):(xcurr,ycurr)})
            neighbors.update({(x-2,y-2):self.evaltar(x-2,y-2)})
      except KeyError:
        pass
      try:
          if((game_board[x-1,y]!='.')&(game_board[x-2,y]=='.')):
            parent.update({(x-2,y):(xcurr,ycurr)})
            neighbors.update({(x-2,y):self.evaltar(x-2,y)})
      except KeyError:
        pass
      try:
        if((game_board[x-1,y+1]!='.')&(game_board[x-2,y+2]=='.')):
          parent.update({(x-2,y+2):(xcurr,ycurr)})
          neighbors.update({(x-2,y+2):self.evaltar(x-2,y+2)})
      except KeyError:
        pass
      
    return neighbors,parent
  
  def all_jump(self,xcurr,ycurr,game_board,ind):
    if(ind==1):
      neigh,par = self.jump(xcurr,ycurr,game_board,1)
      w,u = self.move_adjacent(xcurr,ycurr,game_board)
      par.update(u)
      target_queue = sorted(neigh,key=neigh.__getitem__, reverse=True)
      target_queue.extend(w)
      return target_queue,par
    if(ind==2):
      res=dict()
      p=dict()
      neigh,par = self.jump(xcurr,ycurr,game_board,1)
      w,u = self.move_adjacent(xcurr,ycurr,game_board)
      par.update(u)
      res.update(neigh)
#       p.update(par)
      for n in neigh:
        child,parent = self.jump(n[0],n[1],game_board,1)
#         res.update(child)
#         p.update(parent)
        res.update(child)
        par.update(parent)
      target_queue = sorted(neigh,key=neigh.__getitem__, reverse=True)
      target_queue.extend(w)
      if not target_queue:
        n,p = self.all_jump(xcurr,ycurr,game_board,1)
        return n,p
      else:
        return target_queue,p
    if(ind==3):
      res=dict()
      p=dict()
      neigh,par = self.jump(xcurr,ycurr,game_board,1)
      w,u = self.move_adjacent(xcurr,ycurr,game_board)
      par.update(u)
      res.update(neigh)
      for n in neigh:
        child,parent = self.jump(n[0],n[1],game_board,2)
        res.update(child)
        p.update(parent)
        for c in child:
          ch, pa = self.jump(n[0],n[1],game_board,1)
          res.update(ch)
          p.update(pa)
      target_queue = sorted(res,key=res.__getitem__, reverse=True)
      target_queue.extend(w)
      if not target_queue:
        n,p = self.all_jump(xcurr,ycurr,game_board,2)
        return n,p
      else:
        return target_queue,p          
          
  def move_adjacent(self,x_curr,y_curr,game_board): #need to alter this so we traverse to only the most strategic moves
    x = x_curr
    y = y_curr
    parents=dict()
    neighbors = dict()
    if(y>=1):
      try: #need to make sure it does not go out of bounds
        if(game_board[x+1,y-1]=='.'):
          ut= self.evaltar(x+1,y-1)
          neighbors.update({(x+1,y-1):ut})
      except KeyError:
        pass
      try:
        if(game_board[x,y-1]=='.'):
          ut= self.evaltar(x,y-1)
          neighbors.update({(x,y-1):ut})
      except KeyError:
        pass
    if((x>=1)&(y>=1)):
      try:
        if(game_board[x-1,y-1]=='.'):
          ut= self.evaltar(x-1,y-1)
          neighbors.update({(x-1,y-1):ut})
      except KeyError:
        pass
    if(x>=1):
      try:
        if(game_board[x-1,y]=='.'):
          ut= self.evaltar(x-1,y)
          neighbors.update({(x-1,y):ut})
      except KeyError:
        pass
      try:
        if(game_board[x-1,y+1]=='.'):
          ut= self.evaltar(x-1,y+1)
          neighbors.update({(x-1,y+1):ut})
      except KeyError:
        pass
    for n in neighbors:
      parents.update({(n[0],n[1]):(x,y)})
    targets = sorted(neighbors,key=neighbors.__getitem__, reverse=True)
    return targets,parents

#given the coordinates of the pawns along with time available, we want to know their possible states
def generate_states(game_board,color,jump_index):
  #depending on the color we call the functions as such
  if(color=='B'): #maybe switch this around to call each other
    pawn = Black()
  if(color=='W'):
    pawn = White()
  astates=dict()
  jstates=dict()
  merged_states=dict()
  for p in game_board: #loop over each pawn
    if(game_board[p]==color):
      #indent the rest
      #i = p[1] #row,y
      #j = p[0] #column,x
      adjacent_states = pawn.move_adjacent(p[0],p[1],game_board) #utility must also be updated
      jump_states, jparents = pawn.all_jump(p[0],p[1],game_board,jump_index) #jump states in order of highest utility
      #we can make it so that each pawn will return most optimal adjacent state along with 2 jumpstates.  
      if adjacent_states:
        astates.update({p:adjacent_states})
      if jump_states:
        jstates.update({p:jump_states})

        
  if(jump_index>0):
    return jstates,jparents
  if(jump_index==0):
    return astates,jparents
  
#     return jstates
#   merged_states=combinedict(astates,jstates)
#   return merged_states
#   return astates,jstates

p = generate_states(board,'B',3)
print(p)

def combinedict(dict1,dict2):
  dict3 = {**dict1, **dict2}
  for key, val in dict3.items():
       if key in dict1 and key in dict2:
               dict3[key] = [val , dict1[key]]
 
  return dict3

def minimax(game_board,player,dcutoff,ind):
  #cutoff stuff
  #eval func stuff
  if(player=='B'):
    next_player='W'
  if(player=='W'):
    next_player='B'
  maxscore= -float("inf")
  beta = float("inf")
  best_state = None
  states,parents = generate_states(game_board,next_player,ind)
  
  for s in states: #likely have 19 keys for moving 19 pawns
    schildren=states[s] #list of states resulting from moving pawn s
    for child in schildren: #new position for pawn s
      result=dict()
      result.update(game_board)
      result.update({s:'.'})
      result.update({child:next_player})
      v = get_min(maxscore, beta, result, 1, next_player, dcutoff, ind)
      if(maxscore<v):
        maxscore=v
        best_state = result
      
  return best_state

# m = generate_states(board,'B',1)
# print(m)
show_state(board)
import time
start=time.time()
print(eval_state(mini,'B'))
mini = minimax(board,'W',2,1) #board, player, dcutoff, ind, time_give
finish=time.time()
print("time:",finish-start)
show_state(mini)

show_state(board)

def get_max(alpha, beta, state, d, col, dcutoff, ind):
  if(col=='B'):
    nextp = 'W'
  if(col=='W'):
    nextp = 'B'
#   print(state)
  if(d>dcutoff):
    state_utility = eval_state(state,col) ###
    return state_utility
  v= -float("inf")
  
  generated_result,genparents = generate_states(state,nextp,ind)
  for s in generated_result: #likely have 19 keys for moving 19 pawns
    schildren=generated_result[s] #list of states resulting from moving pawn s
    for child in schildren: #new position for pawn s
      result=dict()
      result.update(state)
      result.update({s:'.'})
      result.update({child:nextp})
      v = max(v, get_min(alpha,beta,result,d+1,col,dcutoff,ind))
      if(v>=beta):
        return v
      alpha = max(alpha,v)
#       print("alpha is,",alpha)
  return v

def get_min(alpha, beta, state, d, col, dcutoff, ind):
  if(col=='B'):
    nextp = 'W'
  if(col=='W'):
    nextp = 'B'
  if(d>dcutoff):
    state_utility = eval_state(state,col) ###
    return state_utility
  v = float("inf")
  generated_result,genparents = generate_states(state,nextp,ind) ##PROBLEM LINE
  for s in generated_result: #likely have 19 keys for moving 19 pawns
    schildren=generated_result[s] #list of states resulting from moving pawn s
    #did not reach here
    for child in schildren: #new position for pawn s
      result=dict()
      result.update(state)
      result.update({s:'.'})
      result.update({child:nextp})
      v = min(v, get_max(alpha,beta,result,d+1,col,dcutoff,ind))
      if(v<=alpha):
        return v
      beta = min(beta,v)
#       print("beta is",beta)
  return v

def single(board,color):
  states,parents = generate_states(board,color,1)
  targets = sorted(neighbors,key=neighbors.__getitem__, reverse=True)
  t = targets.pop(0)
  xnow = t[0]
  ynow = t[1]
  nxt = parents[t]
  xnext = nxt[0]
  ynext = nxt[1]
  
  sq = 2**(1/2)
  if(stline(xnow,ynow,xnext,ynext)<=sq):
    move = 'E'
  if(stline(xnow,ynow,xnext,ynext)>sq):
    move = 'J'
    
  write_output(move_type,xcurr,ycurr,x_coord,y_coord)

def game(board,beststate):
  for k in board.keys():
    if(board[k]!=beststate[k]):
      if(board[k]=='.'):
        xnext=k[0]
        ynext=k[1]
      if(board[k]!='.'):
        xnow=k[0]
        ynow=k[1]
        
  sq = 2**(1/2)
  if(stline(xnow,ynow,xnext,ynext)<=sq):
    move = 'E'
  if(stline(xnow,ynow,xnext,ynext)>sq):
    move = 'J'
    
  write_output(move_type,xcurr,ycurr,x_coord,y_coord)

def stline(x1,y1,x2,y2):
  diff1 = (x1-x2)**2
  diff2 = (y1-y2)**2
  s = sum(diff1,diff2)
  return s**(1/2)

def write_output(move_type,xcurr,ycurr,x_coord,y_coord): #this function creates an output.txt file writes out the moves
  o = open("output.txt","a+")
  if o not empty:
    o.write("\n",move_type," ",x_coord," ",y_coord)
  else:
    o.write(move_type," ",xcurr,ycurr," ",x_coord,y_coord)

def gettime(time):
  if(time<=0.004):
    dcut = 0
    jp = 1
    return dcut,jp
  if(time<0.005):
    dcut = 1
    jp = 1
    return dcut,jp
  if(time<0.006):
    dcut = 1
    jp = 2
    return dcut,jp
  if(time<0.007):
    dcut = 1
    jp = 3
    return dcut,jp
  if(time<0.5):
    dcut = 2
    jp = 2
    return dcut,jp
  if(time<0.6):
    dcut = 2
    jp = 3
    return dcut,jp
  if(time<7):
    dcut = 3
    jp = 1
    return dcut,jp
  if(time<8):
    dcut = 3
    jp = 2
    return dcut,jp
  if(time<10):
    dcut = 3
    jp = 3
    return dcut,jp
  else:
    dcut=2
    jp=3

def show_state(gameboard):
  board=[]
  for row in range(0,16):
    col=[]
    for column in range(0,16):
      col.append(gameboard[column,row])
#     board.append(col)
    print(col,'\n')
    
#   print(board)

def calibrate():
    testdict = dict()
    for x in range(0,16):
        for y in range(0,16):
            testdict.update({(x,y):'.'})
    #update black pawns
    for x1 in range(0,5):
        testdict.update({(x1,0):'B'})
        testdict.update({(x1,1):'B'})
    for x1 in range(0,4):
        testdict.update({(x1,2):'B'})
    for x1 in range(0,3):
        testdict.update({(x1,3):'B'})
    for x1 in range(0,2):
        testdict.update({(x1,4):'B'})
        
    #update white pawns
    for x1 in range(11,16):
        testdict.update({(x1,15):'W'})
        testdict.update({(x1,14):'W'})
    for x1 in range(12,16):
        testdict.update({(x1,13):'W'})
    for x1 in range(13,16):
        testdict.update({(x1,12):'W'})
    for x1 in range(14,16):
        testdict.update({(x1,11):'W'})
    
    #updating board
    testdict.update({(14,12):'.'})
    testdict.update({(12,10):'W'})
    
    testdict.update({(11,13):'.'})
    testdict.update({(9,13):'W'})
    
#     o = open("calibrate.txt","a+")
    
    
    for depth in range(0,3):
        for jump in range(0,3):
            beg = time.time()
            mini = minimax(board,'W',depth,jump)
            end = time.time()
            t = end-beg
#             o.write(depth," ",jump," ",t)
            print(depth,jump,t)
            
calibrate()

import time
start=time.time()
mini = minimax(board,'W',2,1) #board, player, dcutoff, ind
end=time.time()
print(end-start)
show_state(mini)

#THE REAL MAIN
def main():
  f = open("input.txt","r")
  fl = f.readlines()
  gametype = fl[0]
  player_type = fl[1]
  if(player_type=="BLACK"):
    color = 'B'
  if(player_type=="WHITE"):
    color = 'W'
  time_allocated = fl[2]
  game = []
  #we are reading the game board the whole line at a time
  for i in range(1,17): #really iteration from 0-16
    game.append((fl[2+i]).split())


  #blah
  game_board=[]
  board = dict()
  for i in range(0,16): #this is y
  #   print(list(game_board[x][0]))
    game_board.append(list(game[i][0]))
    for j in range(0,16): #this is x
      board.update({(j,i):game[i][0][j]})

  if(gametype=='SINGLE'):
    single(board,color)
    
    
  if(gametype=='GAME'):
    if(color=='B'):
      col = 'W'
    if(color=='W'):
      col = 'B'
    dcutoff,ind = gettime(time_allocated)
    best_state = minimax(board,col,dcutoff,ind)
    game(board,best_state)
  # states = generate_states(....)
  # for s in states:
  #   states[s]+=curr_utility
  # minimax()

def doit():
  b = minimax(board,'W',2,1)
  return b
b=doit()
print(b)







